import Cocoa
import FlutterMacOS
import UserNotifications

import os

private let INITIALIZE_METHOD: String = "initialize"
private let SHOW_METHOD: String = "show"
private let SCHEDULE_METHOD: String = "schedule"
private let PERIODICALLY_SHOW_METHOD: String = "periodicallyShow"
private let SHOW_DAILY_AT_TIME_METHOD: String = "showDailyAtTime"
private let SHOW_WEEKLY_AT_DAY_AND_TIME_METHOD: String = "showWeeklyAtDayAndTime"
private let CANCEL_METHOD: String = "cancel"
private let CANCEL_ALL_METHOD: String = "cancelAll"
private let PENDING_NOTIFICATIONS_REQUESTS_METHOD: String = "pendingNotificationRequests"
private let GET_NOTIFICATION_APP_LAUNCH_DETAILS_METHOD: String = "getNotificationAppLaunchDetails"
private let SELECT_NOTIFICATION_METHOD = "selectNotification"

private let CHANNEL: String = "dexterous.com/flutter/local_notifications"
private let CALLBACK_CHANNEL: String = "dexterous.com/flutter/local_notifications_background"
private let ON_NOTIFICATION_METHOD: String = "onNotification"
private let DID_RECEIVE_LOCAL_NOTIFICATION: String = "didReceiveLocalNotification"

private let DAY: String = "day"

private let REQUEST_SOUND_PERMISSION: String = "requestSoundPermission"
private let REQUEST_ALERT_PERMISSION: String = "requestAlertPermission"
private let REQUEST_BADGE_PERMISSION: String = "requestBadgePermission"
private let DEFAULT_PRESENT_ALERT: String = "defaultPresentAlert"
private let DEFAULT_PRESENT_SOUND: String = "defaultPresentSound"
private let DEFAULT_PRESENT_BADGE: String = "defaultPresentBadge"
private let CALLBACK_DISPATCHER: String = "callbackDispatcher"
private let ON_NOTIFICATION_CALLBACK_DISPATCHER: String = "onNotificationCallbackDispatcher"
private let PLATFORM_SPECIFICS: String = "platformSpecifics"
private let ID: String = "id"
private let TITLE: String = "title"
private let BODY: String = "body"
private let SOUND: String = "sound"
private let PRESENT_ALERT: String = "presentAlert"
private let PRESENT_SOUND: String = "presentSound"
private let PRESENT_BADGE: String = "presentBadge"
private let BADGE_NUMBER: String = "badgeNumber"
private let MILLISECONDS_SINCE_EPOCH: String = "millisecondsSinceEpoch"
private let REPEAT_INTERVAL: String = "repeatInterval"
private let REPEAT_TIME: String = "repeatTime"
private let HOUR: String = "hour"
private let MINUTE: String = "minute"
private let SECOND: String = "second"

private let NOTIFICATION_ID: String = "NotificationId"
private let PAYLOAD: String = "payload"
private let NOTIFICATION_LAUNCHED_APP: String = "notificationLaunchedApp"

enum RepeatInterval: Int {
  case EveryMinute
  case Hourly
  case Daily
  case Weekly
}

// Why are there so many #available(OSX 10.14, *) in this file? Because (for now) we are using Notification APIs
// only available on 10.14+, but marking the entire class as @available(OSX 10.14, *) would cause a build failure
// in GeneratedPluginRegistrant.swift, which is generated by Flutter build and we can't add OSX version check there
//
// Note that it's a compile time error (seriously), so even though MainFlutterWindow will never see this file
// unless the running on 10.14+, we still have to put the checks here
public class FlutterLocalNotificationsPlugin: NSObject, FlutterPlugin, UNUserNotificationCenterDelegate {
  private var channel: FlutterMethodChannel? = nil
  private var displayAlert: Bool = false
  private var playSound: Bool = false
  private var updateBadge: Bool = false
  private var initialized: Bool = false
  private var launchingAppFromNotification = false
  private var persistentState: UserDefaults? = nil
  private var registrar: FlutterPluginRegistrar? = nil
  private var launchPayload: String? = nil
  private var launchNotification: Any? = nil  // UNNotificationRequest

  public static func register(with registrar: FlutterPluginRegistrar) {
    guard #available(OSX 10.14, *) else {
      return
    }

    let channel = FlutterMethodChannel(name: CHANNEL, binaryMessenger: registrar.messenger)

    let instance = FlutterLocalNotificationsPlugin()
    instance.channel = channel
    instance.registrar = registrar
    instance.persistentState = UserDefaults.standard
    UNUserNotificationCenter.current().delegate = instance

    registrar.addMethodCallDelegate(instance, channel: channel)
  }

  public func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
    guard #available(OSX 10.14, *) else {
      return
    }

    switch call.method {
    case INITIALIZE_METHOD:
      initialize(call, result: result)
    case SHOW_METHOD, SCHEDULE_METHOD, PERIODICALLY_SHOW_METHOD, SHOW_DAILY_AT_TIME_METHOD, SHOW_WEEKLY_AT_DAY_AND_TIME_METHOD:
      showNotification(call, result: result)
    case CANCEL_METHOD:
      cancelNotification(call, result: result)
    case CANCEL_ALL_METHOD:
      cancelAllNotification(call, result: result)
    case GET_NOTIFICATION_APP_LAUNCH_DETAILS_METHOD:
      var payload: String? = nil
      if let launchNotification = launchNotification as? UNNotificationRequest {
        payload = launchNotification.content.userInfo[PAYLOAD] as? String
      } else {
        payload = launchPayload
      }
      let notificationAppLaunchDetails: [String: Any?] = [
        NOTIFICATION_LAUNCHED_APP: launchingAppFromNotification,
        PAYLOAD: payload
      ]
      result(notificationAppLaunchDetails)
    case PENDING_NOTIFICATIONS_REQUESTS_METHOD:
      pendingNotificationRequests(result: result)
    default:
      result(FlutterMethodNotImplemented)
    }
  }

  private func initialize(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
    guard #available(OSX 10.14, *) else {
      return
    }

    guard let args = call.arguments as? [String: Any] else {
      return
    }

    if let value = args[DEFAULT_PRESENT_ALERT] as? Bool {
      displayAlert = value
    }
    if let value = args[DEFAULT_PRESENT_SOUND] as? Bool {
      playSound = value
    }
    if let value = args[DEFAULT_PRESENT_BADGE] as? Bool {
      updateBadge = value
    }

    var requestedAlertPermission: Bool = false
    if let value = args[REQUEST_ALERT_PERMISSION] as? Bool {
      requestedAlertPermission = value
    }
    var requestedSoundPermission: Bool = false
    if let value = args[REQUEST_SOUND_PERMISSION] as? Bool {
      requestedSoundPermission = value
    }
    var requestedBadgePermission: Bool = false
    if let value = args[REQUEST_BADGE_PERMISSION] as? Bool {
      requestedBadgePermission = value
    }

    var authorizationOptions = UNAuthorizationOptions()
    if (requestedAlertPermission) {
      authorizationOptions = authorizationOptions.union(UNAuthorizationOptions.alert)
    }
    if (requestedSoundPermission) {
      authorizationOptions = authorizationOptions.union(UNAuthorizationOptions.sound)
    }
    if (requestedBadgePermission) {
      authorizationOptions = authorizationOptions.union(UNAuthorizationOptions.badge)
    }

    let center = UNUserNotificationCenter.current()
    center.requestAuthorization(options: authorizationOptions, completionHandler: {
      (granted: Bool, error: Error?) in
      if let launchPayload = self.launchPayload {
        self.handleSelectNotification(launchPayload)
      }
      result(granted)
    })

    initialized = true
  }

  private func showNotification(_ call: FlutterMethodCall, result: FlutterResult) {
    guard let arguments = call.arguments else { return }
    guard let args = arguments as? [String: Any] else { return }

    guard let id = args[ID] as? Int else { return }
    guard let payload = args[PAYLOAD] as? String else { return }

    var title = ""
    if let value = args[TITLE] as? String {
      title = value
    }

    var body = ""
    if let value = args[BODY] as? String {
      body = value
    }

    var presentAlert = self.displayAlert
    var presentSound = self.playSound
    var presentBadge = self.updateBadge
    var badgeNumber = -1
    var sound = ""

    if let platformSpecs = args[PLATFORM_SPECIFICS] as? [String: Any] {
      if let value = platformSpecs[PRESENT_ALERT] as? Bool {
        presentAlert = value
      }
      if let value = platformSpecs[PRESENT_SOUND] as? Bool {
        presentSound = value
      }
      if let value = platformSpecs[PRESENT_BADGE] as? Bool {
        presentBadge = value
      }
      if let value = platformSpecs[BADGE_NUMBER] as? Int {
        badgeNumber = value
      }
      if let value = platformSpecs[SOUND] as? String {
        sound = value
      }
    }

    let method = call.method
    var secondsSinceEpoch = -1
    var repeatInterval = -1
    var repeatTime = NotificationTime(hour: -1, minute: -1, second: -1)
    var day = -1

    if SCHEDULE_METHOD == method {
      secondsSinceEpoch = (args[MILLISECONDS_SINCE_EPOCH] as! Int) / 1000
    } else if PERIODICALLY_SHOW_METHOD == method ||
        SHOW_DAILY_AT_TIME_METHOD == method ||
        SHOW_WEEKLY_AT_DAY_AND_TIME_METHOD == method {
      if let timeArgs = args[REPEAT_TIME] as? [String: Int] {
        if let value = timeArgs[HOUR] {
          repeatTime.hour = value
        }
        if let value = timeArgs[MINUTE] {
          repeatTime.minute = value
        }
        if let value = timeArgs[SECOND] {
          repeatTime.second = value
        }
      }
      if let value = args[DAY] as? Int {
        day = value
      }
      if let value = args[REPEAT_INTERVAL] as? Int {
        repeatInterval = value
      }
    }

    let notificationDetails = NotificationDetails(
      id: id,
      title: title,
      body: body,
      payload: payload,
      presentAlert: presentAlert,
      presentSound: presentSound,
      presentBadge: presentBadge,
      sound: sound,
      secondsSinceEpoch: secondsSinceEpoch,
      repeatInterval: repeatInterval,
      repeatTime: repeatTime,
      day: day,
      badgeNumber: NSNumber(value: badgeNumber)
    )

    showUserNotification(notificationDetails)
    result(nil)
  }

  private func showUserNotification(_ notificationDetails: NotificationDetails) {
    guard #available(OSX 10.14, *) else {
      return
    }

    let content = UNMutableNotificationContent()
    content.title = notificationDetails.title
    content.body = notificationDetails.body
    if notificationDetails.badgeNumber.int32Value > 0 {
      content.badge = notificationDetails.badgeNumber
    }

    content.sound = UNNotificationSound.default
    if notificationDetails.presentSound && notificationDetails.sound != "" {
      content.sound = UNNotificationSound(named: UNNotificationSoundName(notificationDetails.sound))
    }

    content.userInfo = [
      NOTIFICATION_ID: notificationDetails.id,
      TITLE: notificationDetails.title,
      PRESENT_ALERT: notificationDetails.presentAlert,
      PRESENT_SOUND: notificationDetails.presentSound,
      PRESENT_BADGE: notificationDetails.presentBadge,
      PAYLOAD: notificationDetails.payload,
    ]

    var trigger: UNNotificationTrigger? = nil

    if notificationDetails.secondsSinceEpoch < 0 {
      var timeInterval = TimeInterval(0.1)
      var repeats = false
      if notificationDetails.repeatInterval > 0 {
        repeats = true

        switch notificationDetails.repeatInterval {
        case RepeatInterval.EveryMinute.rawValue:
          timeInterval = 60
        case RepeatInterval.Hourly.rawValue:
          timeInterval = 60 * 60
        case RepeatInterval.Daily.rawValue:
          timeInterval = 60 * 60 * 24
        case RepeatInterval.Weekly.rawValue:
          timeInterval = 60 * 60 * 24 * 7
        default:
          timeInterval = 0.1
        }
      }

      if notificationDetails.repeatTime.hour >= 0 {
        let calendar = Calendar(identifier: Calendar.Identifier.gregorian)
        var dateComponents = DateComponents()
        dateComponents.calendar = calendar
        if notificationDetails.day > 0 {
          dateComponents.weekday = notificationDetails.day
        }
        dateComponents.hour = notificationDetails.repeatTime.hour
        dateComponents.minute = notificationDetails.repeatTime.minute
        dateComponents.second = notificationDetails.repeatTime.second
        trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: repeats)
      } else {
        trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeInterval, repeats: repeats)
      }
    } else {
      let date = Date(timeIntervalSince1970: Double(notificationDetails.secondsSinceEpoch))
      let calendar = Calendar.current
      let dateComponents = calendar.dateComponents([Calendar.Component.year, Calendar.Component.month, Calendar.Component.day, Calendar.Component.hour, Calendar.Component.minute, Calendar.Component.second], from: date)
      trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: false)
    }

    let request = UNNotificationRequest(identifier: String(notificationDetails.id), content: content, trigger: trigger)
    let center = UNUserNotificationCenter.current()
    center.add(request, withCompletionHandler: { (error: Error?) in
      if let err = error {
        os_log("%@", err.localizedDescription)
      }
    })
  }

  private func cancelNotification(_ call: FlutterMethodCall, result: FlutterResult) {
    guard #available(OSX 10.14, *) else {
      return
    }

    let id = call.arguments as! Int
    let center = UNUserNotificationCenter.current()
    let toRemove = [String(id)]
    center.removePendingNotificationRequests(withIdentifiers: toRemove)
    center.removeDeliveredNotifications(withIdentifiers: toRemove)
    result(nil)
  }

  private func cancelAllNotification(_ call: FlutterMethodCall, result: FlutterResult) {
    guard #available(OSX 10.14, *) else {
      return
    }

    let center = UNUserNotificationCenter.current()
    center.removeAllPendingNotificationRequests()
    center.removeAllDeliveredNotifications()
    result(nil)
  }

  private func pendingNotificationRequests(result: FlutterResult) {
    guard #available(OSX 10.14, *) else {
      return
    }

    var pendingNotificationRequests: [[String: Any?]] = []
    let center: UNUserNotificationCenter = UNUserNotificationCenter.current()
    center.getPendingNotificationRequests(completionHandler: { (requests: [UNNotificationRequest]) in
      for request in requests {
        let pendingNotificationRequest: [String: Any?] = [
          ID: request.content.userInfo[NOTIFICATION_ID],
          TITLE: request.content.title,
          BODY: request.content.body,
          PAYLOAD: request.content.userInfo[PAYLOAD],
        ]
        pendingNotificationRequests.append(pendingNotificationRequest)
      }
    })
    result(pendingNotificationRequests)
  }

  private func handleSelectNotification(_ payload: String) {
    channel?.invokeMethod(SELECT_NOTIFICATION_METHOD, arguments: payload)
  }

  @available(OSX 10.14, *)
  @objc public func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
    var presentationOptions = UNNotificationPresentationOptions(rawValue: 0)
    if let alert = notification.request.content.userInfo[PRESENT_ALERT] as? Bool {
      if alert {
        presentationOptions = presentationOptions.union(UNNotificationPresentationOptions.alert)
      }
    }
    if let sound = notification.request.content.userInfo[PRESENT_SOUND] as? Bool {
      if sound {
        presentationOptions = presentationOptions.union(UNNotificationPresentationOptions.sound)
      }
    }
    if let badge = notification.request.content.userInfo[PRESENT_BADGE] as? Bool {
      if badge {
        presentationOptions = presentationOptions.union(UNNotificationPresentationOptions.badge)
      }
    }

    completionHandler(presentationOptions)
  }

  private func isAFlutterLocalNotification(_ userInfo: [AnyHashable: Any]?) -> Bool {
    guard #available(OSX 10.14, *) else {
      return false
    }

    guard let info = userInfo else { return false }
    return info[NOTIFICATION_ID] != nil && info[TITLE] != nil && info[PRESENT_ALERT] != nil && info[PRESENT_SOUND] != nil && info[PRESENT_BADGE] != nil && info[PAYLOAD] != nil
  }

  @available(OSX 10.14, *)
  @objc public func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Void) {
    if response.actionIdentifier == UNNotificationDefaultActionIdentifier && isAFlutterLocalNotification(response.notification.request.content.userInfo) {
      let payload = response.notification.request.content.userInfo[PAYLOAD] as! String
      if (initialized) {
        handleSelectNotification(payload)
      } else {
        launchPayload = payload
        launchingAppFromNotification = true
      }
    }
  }
}
